# verify that information_schema.tokudb_locks gets populated with locks, information_schema.tokudb_lock_waits gets
# populated with 1 lock_wait and all transactions are present in information_schema.tokudb_trx for 2 clients

source include/have_tokudb.inc;
set default_storage_engine='tokudb';
set tokudb_prelock_empty=false;
disable_warnings;
drop table if exists t;
enable_warnings;

create table t (id int primary key);
set autocommit=0;
let $default_id=`select connection_id()`;

# should be empty
select * from information_schema.tokudb_locks;
select * from information_schema.tokudb_lock_waits;
select * from information_schema.tokudb_trx;

connect (conn_a,localhost,root,,);
set autocommit=0;
let $a_id=`select connection_id()`;

insert into t values (1);

connect (conn_b,localhost,root,,);
set autocommit=0;
let $b_id=`select connection_id()`;

send insert into t values (1);


# should find the presence of a lock on 1st transaction
connection default;
replace_column 1 TRX_ID 2 MYSQL_ID; 
eval select * from information_schema.tokudb_locks;

# should find the presence of a lock_wait on the 2nd transaction
replace_column 1 REQUEST_TRX_ID 2 BLOCK_TRX_ID 6 LOCK_WAITS_START_TIME;
eval select * from information_schema.tokudb_lock_waits;

# should find the presence of two transactions
replace_column 1 TRX_ID 2 MYSQL_ID;
eval select * from information_schema.tokudb_trx;

connection conn_a;
commit;
# verify that the lock on the 1st transaction is released and replaced by the lock for the 2nd transaction
replace_column 1 TRX_ID 2 MYSQL_ID;
eval select * from information_schema.tokudb_locks;

connection conn_b;
--error 1062
reap;
commit;

disconnect conn_b;

connection default;
# verify that the lock on the 2nd transaction has been released
# should be be empty
select * from information_schema.tokudb_locks;


drop table t;
