/********************************************************************
Get number of elements in vector. */
UNIV_INLINE
ulint
ib_vector_size(
/*===========*/
				/* out: number of elements in vector */
	const ib_vector_t*	vec)	/* in: vector */
{
	return(vec->used);
}

/********************************************************************
Get n'th element. */
UNIV_INLINE
void*
ib_vector_get(
/*==========*/
				/* out: n'th element */
	ib_vector_t*	vec,	/* in: vector */
	ulint		n)	/* in: element index to get */
{
	ut_a(n < vec->used);

	return(vec->data[n]);
}

/********************************************************************
Remove the last element from the vector. */
UNIV_INLINE
void*
ib_vector_pop(
/*==========*/
				/* out: last vector element */
	ib_vector_t*    vec)    /* in/out: vector */
{
	void*           elem;

	ut_a(vec->used > 0);
	--vec->used;
	elem = vec->data[vec->used];

	ut_d(vec->data[vec->used] = NULL);
	UNIV_MEM_INVALID(&vec->data[vec->used], sizeof(*vec->data));

	return(elem);
}

/********************************************************************
Free the underlying heap of the vector. Note that vec is invalid
after this call. */
UNIV_INLINE
void
ib_vector_free(
/*===========*/
	ib_vector_t*    vec)    /* in, own: vector */
{
	mem_heap_free(vec->heap);
}

/********************************************************************
Test whether a vector is empty or not. */
UNIV_INLINE
ibool
ib_vector_is_empty(
/*===============*/			/* out: TRUE if empty else FALSE */
	const ib_vector_t*	vec)	/* in vector to test */
{
	return(ib_vector_size(vec) == 0);
}
